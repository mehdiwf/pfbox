* rust snippets/crates
** 2 dimensional array
https://stackoverflow.com/questions/13212212/creating-two-dimensional-arrays-in-rust
#+begin_src rust
let mut state = [[0u8; 4]; 6];
state[0][1] = 42;
#+end_src
** unknown toml
https://stackoverflow.com/questions/72690767/how-to-parse-toml-in-rust-with-unknown-structure
** float comparison
https://stackoverflow.com/questions/41447678/comparison-of-two-floats-in-rust-to-arbitrary-level-of-precision
** creating dir
#+begin_src rust
use std::fs;
fs::create_dir("MyDir").expect("problem creating the directory");
#+end_src
** csv
https://docs.rs/csv/latest/csv/
** c++/rust interop
https://cxx.rs/
** bindgen c / rust interop
https://rust-lang.github.io/rust-bindgen/
* code dependencies
** flamegraph-rs
#+begin_src 
sudo apt install linux-tools-common linux-tools-generic linux-tools-`uname -r`
#+end_src

** rgsl
for rgsl:
(debian)
#+begin_src 
sudo apt-get install libgsl0-dev
#+end_src
* orga code building
** todos
*** verify with samy
**** eta0

shear visc = eta0 * m * rho

eta0 is the dynamic viscosity? (changed the definition in fcts)

**** zeta0

eta0 * mass * rho

cin_visc = eta0?

*** TODO make the program take arguments from input file
and choose which arguments to fix and which to get in input!
*** TODO fix row_dx/col_dx in BoxInfo definition
*** TODO understand why there is a jump in some simulations
**** vdw file with jump?
use std::io::Write; // to use "write_all" method
use std::fs; // to read/write a file contents
use rgsl::logarithm::log;
use rgsl::exponential::exp;
use crate::maths::fcts::*;
use crate::maths::mystructs::*;


fn create_scalar_grid(ncol_size: i32,
                      nrow_size: i32) -> ScalarField2D
{
    return ScalarField2D {
        s: vec![vec![0.; ncol_size as usize];
                nrow_size as usize],
    };
}

fn create_vector_grid(ncol_size: i32,
                      nrow_size: i32) -> VectorField2D
{
    let result = VectorField2D
    {
        x: vec![vec![0.; ncol_size as usize];
                nrow_size as usize],
        y: vec![vec![0.; ncol_size as usize];
                nrow_size as usize]
    };
    return result;
}

fn create_tensor_grid(ncol_size: i32,
                      nrow_size: i32) -> TensorField2D
{
    let result = TensorField2D
        {
            xx: vec![vec![0.; ncol_size as usize];
                     nrow_size as usize],
            xy: vec![vec![0.; ncol_size as usize];
                     nrow_size as usize],
            yx: vec![vec![0.; ncol_size as usize];
                     nrow_size as usize],
            yy: vec![vec![0.; ncol_size as usize];
                     nrow_size as usize]
        };
    return result;
}

pub fn do_sim() {
    let do_vdw_sim = true;
    // let do_vdw_sim = false;
    // env::set_var("RUST_BACKTRACE", "1");
    let output_dir = "./testoutput";
    let output_dir = "/home/mehdi/workdir/dossiers/ilm/these/code_simulations/rust_implementation/pfbox_git/src/testoutput";
    let path = format!("{}/log.txt", output_dir);
    // Open/Create a file in write-only mode, returns `io::Result<File>`
    let file = match fs::File::create(&path) {
        Err(why) => panic!("couldn't create logfile {}: {}", path, why),
        Ok(file) => file,
    };
    // Open an already created file
    let mut file = fs::OpenOptions::new()
        .write(true)
        .append(true) // This is needed to append to file
        .open(&path)
        .unwrap();

    let str_to_append = format!("new sim\n");
    // appending the string to 
    file.write_all(&str_to_append.as_bytes());
    
    // System initialisation
    let mut step = 0;
    let max_time_step = 1_000;
    // let step_count_before_save = max_time_step/20;
    let step_count_before_save = max_time_step/10;

    let print_frequency = 20.;
    let mut print_percertage_threshold = 100./print_frequency;
    
    let dt = 1e-2;
    let mut time = 0.;

    let ncol_size = 100;
    let nrow_size = 2;

    let rho_liq0 = 0.8;
    let ln_rho_liq0 = log(rho_liq0);
    let rho_vap0 = 0.02;
    let ln_rho_vap0 = log(rho_vap0);
    let temp0 = 0.7;

    let box_info = BoxInfo{col_max: ncol_size,
                           row_max: nrow_size};

    if do_vdw_sim {

    //auie physics quantities definition
    ////////////////////////////////////////////////////////////////////////////
    // Physics quantities definition
    ////////////////////////////////////////////////////////////////////////////
    // GD for grid
    let mut GD_rho = create_scalar_grid(ncol_size, nrow_size);
    let mut GD_temp = create_scalar_grid(ncol_size, nrow_size);
    let mut GD_pressure = create_tensor_grid(ncol_size, nrow_size);
    // momentum, also known as J = rho*velocity
    let mut GD_J = create_vector_grid(ncol_size, nrow_size);
    // velocity
    let mut GD_v = create_vector_grid(ncol_size, nrow_size);

    //auie quantities used for the computations definition
    ////////////////////////////////////////////////////////////////////////////
    // Quantities used for the computations definition
    ////////////////////////////////////////////////////////////////////////////
    
    let mut GD_ln_rho = create_scalar_grid(ncol_size, nrow_size);
    let mut GD_grad_rho = create_vector_grid(ncol_size, nrow_size);
    let mut GD_lap_rho = create_scalar_grid(ncol_size, nrow_size);

    let mut GD_vJ = create_tensor_grid(ncol_size, nrow_size);

    let mut GD_grad_v = create_tensor_grid(ncol_size, nrow_size);

    let mut GD_div_v = create_scalar_grid(ncol_size, nrow_size);

    let mut GD_traceless_grad_v = create_tensor_grid(ncol_size, nrow_size);

    let mut GD_lap_v = create_vector_grid(ncol_size, nrow_size);

    let mut GD_div_vJ = create_vector_grid(ncol_size, nrow_size);
    let mut GD_grad_div_v = create_vector_grid(ncol_size, nrow_size);

    let mut GD_div_press = create_vector_grid(ncol_size, nrow_size);

    let mut GD_ln_rho_traceless_grad_v = create_vector_grid(ncol_size, nrow_size);
    
    let inv_cv = 1.0/(1.5*kB);

    let mut GD_traceless_grad_v_dyadic_grad_v = create_scalar_grid(ncol_size, nrow_size);

    let mut GD_grad_ln_rho_scalar_grad_T = create_scalar_grid(ncol_size, nrow_size);

    let mut GD_grad_ln_rho = create_vector_grid(ncol_size, nrow_size);

    let mut GD_v_scalar_grad_ln_rho = create_scalar_grid(ncol_size, nrow_size);

    let mut GD_grad_ln_rho_traceless_grad_v = create_vector_grid(ncol_size, nrow_size);
    
    let mut GD_grad_T = create_vector_grid(ncol_size, nrow_size);

    let mut GD_lap_T = create_scalar_grid(ncol_size, nrow_size);

    let mut GD_v_scalar_grad_T = create_scalar_grid(ncol_size, nrow_size);

    //auie fluid initial state
    ////////////////////////////////////////////////////////////////////////////
    // Fluid initial state
    ////////////////////////////////////////////////////////////////////////////
    
    for col in 0usize..ncol_size as usize {
        for row in 0usize..nrow_size as usize {
            // putting liquid in the first half
            if ((col as i32) < ncol_size/2){
                GD_rho.set_pos(row, col,
                               &rho_liq0);
                GD_ln_rho.set_pos(row, col,
                                  &ln_rho_liq0);}
            else {GD_rho.set_pos(row, col,
                                 &rho_vap0);
                  GD_ln_rho.set_pos(row, col,
                                    &ln_rho_vap0);}

            // setting initial temperature
            GD_temp.set_pos(row, col, &temp0);
        }}
    

    //auie computation variables update
    ////////////////////////////////////////////////////////////////////////////
    // Computations variables update
    ////////////////////////////////////////////////////////////////////////////

    //auie time loop
    for i_time_step in 0..max_time_step {

        step = i_time_step;
        let percentage_done = 100.*(step as f64/max_time_step as f64);
        if (percentage_done > print_percertage_threshold)
        {
            print_percertage_threshold += 100./print_frequency;
            println!("completed {percentage_done:.1}%");
        }

    // update of computations variables
    for col in 0usize..ncol_size as usize {
        for row in 0usize..nrow_size as usize {

            let col_i32 = col as i32;
            let row_i32 = row as i32;

            // -------------------------------------------------------
            // GD_lap_rho begin update
            GD_lap_rho
                .set_pos(row, col,
                         &laplacian(&GD_rho,
                                    row_i32, col_i32,
                                    &box_info));
            // GD_lap_rho end update
            // -------------------------------------------------------

            // -------------------------------------------------------
            // GD_lap_T begin update
            GD_lap_T
                .set_pos(row, col,
                         &laplacian(&GD_temp,
                                    row_i32, col_i32,
                                    &box_info));
            // GD_lap_T end update
            // -------------------------------------------------------

            // -------------------------------------------------------
            // GD_grad_T begin update
            GD_grad_T
                .set_pos(row, col,
                         &gradient(&GD_temp,
                                   row_i32, col_i32,
                                   &box_info));
            // GD_grad_T end update
            // -------------------------------------------------------

            // -------------------------------------------------------
            // GD_grad_rho begin update
            GD_grad_rho
                .set_pos(row, col,
                         &gradient(&GD_rho,
                                   row_i32, col_i32,
                                   &box_info));
            // GD_grad_rho end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_ln_rho begin update
            // :todo:log:
            let rho = GD_rho.get_pos(row, col);
            if (rho < 0.) {
                let str_to_append = format!("step {}, col={}, row={}\n\
                                             neg log: {}\n\
                                             ------------\n",
                                            &step, &col, &row, &rho);
                // appending the string to 
                file.write_all(&str_to_append.as_bytes())
                    .expect("write failed");
                println!("error step {}:\n\
                          negative rho: rho = {}", step, rho);
            GD_ln_rho
                .set_pos(row, col,
                         &0.);}
            else {
                let ln_rho = log(rho);
                GD_ln_rho
                    .set_pos(row, col,
                             &ln_rho);}
            // GD_ln_rho end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_lap_v begin update
            GD_lap_v
                .set_pos(row, col,
                         &laplacian_vector(&GD_v,
                                           row_i32, col_i32,
                                           &box_info));
            // GD_lap_v end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_div_v begin update
            GD_div_v
                .set_pos(row, col,
                         &div_vector(&GD_v,
                                     row_i32, col_i32,
                                     &box_info));
            // GD_div_v end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_grad_v begin update
            GD_grad_v
                .set_pos(row, col,
                         &gradient_vector(&GD_v,
                                          row_i32, col_i32,
                                          &box_info));
            // GD_grad_v end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_grad_ln_rho begin update
            GD_grad_ln_rho
                .set_pos(row, col,
                         &gradient(&GD_ln_rho,
                                   row_i32, col_i32,
                                   &box_info));
            // GD_grad_ln_rho end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_grad_div_v begin update
            GD_grad_div_v
                .set_pos(row, col,
                         &grad_div_vel(&GD_v,
                                       row_i32, col_i32,
                                       &box_info));
            // GD_grad_div_v end update
            // -------------------------------------------------------

            // -------------------------------------------------------
            // GD_traceless_grad_v begin update
            {
                let grad_v = GD_grad_v.get_pos(row, col);
                let div_v = GD_div_v.get_pos(row, col);
                
                let traceless_grad_v = tens2D {
                    xx: 2.*grad_v.xx - (2./(1.*dim as f64)) * div_v,
                    xy: grad_v.xy + grad_v.yx,
                    yx: grad_v.xy + grad_v.yx,
                    yy: 2.*grad_v.yy - (2./(1.*dim as f64)) * div_v};
                
                GD_traceless_grad_v.set_pos(row, col,
                                            &traceless_grad_v);
            }
            // GD_traceless_grad_v end update
            // -------------------------------------------------------

            // -------------------------------------------------------
            // GD_vJ begin update
            {
                let v = GD_v.get_pos(row, col);
                let J = GD_J.get_pos(row, col);
                let tens_vJ = tens2D{
                    xx: v.x * J.x,
                    xy: v.x * J.y,
                    yx: v.y * J.x,
                    yy: v.y * J.y
                };
                GD_vJ
                    .set_pos(row, col,
                             &tens_vJ)
            }
            // GD_vJ end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_div_vJ begin update            
            GD_div_vJ
                .set_pos(row, col,
                         &div_tensor(&GD_vJ,
                                     row_i32, col_i32,
                                     &box_info));
            // GD_div_vJ end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_v_scal_grad_T begin update            
            GD_v_scalar_grad_T
                .set_pos(row, col,
                         &scal_product(&GD_v.get_pos(row, col),
                                       &GD_grad_T.get_pos(row, col)));
            // GD_v_scal_grad_T end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_traceless_grad_v_dyadic_grad_v begin update            
            GD_traceless_grad_v_dyadic_grad_v
                .set_pos(row, col,
                         &dyadic_product(&GD_traceless_grad_v.get_pos(row, col),
                                         &GD_grad_v.get_pos(row, col)));
            // GD_traceless_grad_v_dyadic_grad_v end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_v_scalar_grad_ln_rho begin update            
            GD_v_scalar_grad_ln_rho
                .set_pos(row, col,
                         &scal_product(&GD_v.get_pos(row, col),
                                       &GD_grad_ln_rho.get_pos(row, col)));
            // GD_v_scalar_grad_ln_rho end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_pressure begin update            
            GD_pressure
                .set_pos(row, col,
                         &pressure(GD_rho.get_pos(row, col),
                                   &GD_grad_rho.get_pos(row, col),
                                   GD_lap_rho.get_pos(row, col),
                                   GD_temp.get_pos(row, col)));
            // GD_pressure end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_grad_ln_rho_traceless_grad_v begin update
            
            GD_grad_ln_rho_traceless_grad_v
                .set_pos(row, col,
                         &tens_product_vec(
                             &GD_traceless_grad_v.get_pos(row, col),
                             &GD_grad_ln_rho.get_pos(row, col)));
            // GD_grad_ln_rho_traceless_grad_v end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // GD_grad_ln_rho_scalar_grad_T begin update
            GD_grad_ln_rho_scalar_grad_T
                .set_pos(row, col,
                         &scal_product(&GD_grad_ln_rho.get_pos(row, col),
                                       &GD_grad_T.get_pos(row, col)));
            // GD_grad_ln_rho_scalar_grad_T end update
            // -------------------------------------------------------


            // -------------------------------------------------------
            // div_press begin update
            GD_div_press
                .set_pos(row, col,
                         &div_tensor(&GD_pressure, row_i32, col_i32,
                                     &box_info));
            // div_press end update
            // -------------------------------------------------------


        }} // updating computations values end parenthesis

    //bépo WRITING part

        if (step % step_count_before_save == 0) {
        
        let filename = format!("{}/step_{}",
                               output_dir, i_time_step);
        let mut file = fs::File::create(&filename)
            .expect("couldn't create log file");
        
        file.write_all(
            "# column density temperature\n".as_bytes())
            .expect("write failed");

        let rho_profile = GD_rho.x_profile();
        let temp_profile = GD_temp.x_profile();
        
        for col_index in 0usize..ncol_size as usize
        {
            let str_to_append = format!("{} {} {}\n",
                                        &col_index,
                                        &rho_profile[col_index],
                                        &temp_profile[col_index]);

            file.write_all(&str_to_append.as_bytes())
                .expect("write failed");
        }}
    // let str_to_append = format!("step {}, i={}, j={}\n\
    //                              neg log {}\n\
    //                              ------------\n",
    //                             &step, &i, &j, &rho);
    //     // appending the string to 
    //     file.write_all(&str_to_append.as_bytes())
    //         .expect("write failed");
        

    //auie main loop
    ////////////////////////////////////////////////////////////////////////////
    // Main loop
    ////////////////////////////////////////////////////////////////////////////
    
    for row in 0usize..nrow_size as usize {
        for col in 0usize..ncol_size as usize {

            let row_i32 = row as i32;
            let col_i32 = col as i32;

            let div_vJ = GD_div_vJ.get_pos(row, col);
            let rho = GD_rho.get_pos(row, col);
            let lap_v = GD_lap_v.get_pos(row, col);
            let grad_div_v = GD_grad_div_v.get_pos(row, col);
            let grad_ln_rho_traceless_grad_v =
                GD_grad_ln_rho_traceless_grad_v.get_pos(row, col);
            let grad_ln_rho = GD_grad_ln_rho.get_pos(row, col);
            let div_v = GD_div_v.get_pos(row, col);
            let div_press = GD_div_press.get_pos(row, col);
            let ln_rho = GD_ln_rho.get_pos(row, col);
            let v_grad_ln_rho = GD_v_scalar_grad_ln_rho.get_pos(row, col);
            let temp = GD_temp.get_pos(row, col);            
            let traceless_grad_v_dyadic_grad_v = GD_traceless_grad_v_dyadic_grad_v.get_pos(row, col);
            let grad_ln_rho_scalar_grad_T = GD_grad_ln_rho_scalar_grad_T.get_pos(row, col);
            let lap_T = GD_lap_T.get_pos(row, col);
            let v_scalar_grad_T = GD_v_scalar_grad_T.get_pos(row, col);
            let J = GD_J.get_pos(row, col);
            
            //bépo MOMENTUM conservation

            let mut new_J = vec2D
            {
                x: J.x +
                    (- div_vJ.x
	             + eta0 * rho * lap_v.x
                     + eta0 * (1.-2./(1.*dim as f64) + zeta0)
                     * rho * grad_div_v.x
	             + eta0 * rho * grad_ln_rho_traceless_grad_v.x
                     + zeta0 * rho * grad_ln_rho.x * div_v
                     - div_press.x)
                    * dt,
                y: J.y + 
                    (- div_vJ.y
	             + eta0 * rho * lap_v.y
                     + eta0 * (1.-2./(1.*dim as f64) + zeta0)
                     * rho * grad_div_v.y
	             + eta0 * rho * grad_ln_rho_traceless_grad_v.y
                     + zeta0 * rho * grad_ln_rho.y * div_v
                     - div_press.y)
                    * dt
            };

            // if you want gravity
            // J.y += -rho * gravity * dt;

            GD_J.set_pos(row, col, &new_J);

            //bépo MASS conservation

            // without ln_rho :
            //rho[i][j] -= div_J[i][j]*dt;
            
            let mut new_ln_rho = ln_rho -
                (div_v + v_grad_ln_rho) * dt;
            let mut new_rho = exp(new_ln_rho);
            
            GD_ln_rho.set_pos(row, col, &new_ln_rho);
            GD_rho.set_pos(row, col, &new_rho);

            //bépo VELOCITY from momentum
            GD_v.set_pos(row, col,
                         &vec2D{x: new_J.x/new_rho,
                                y: new_J.y/new_rho});
            
            //bépo TEMPERATURE ENERGY conservation
            
            // term l div_v

            let mut new_T = temp +
                inv_cv *
                (
                    // term l div_v
                    -kB * temp * (1. + rho * b/(1.-rho * b)) * div_v 
                    // term dissipative_stress_grad_v
                    + eta0 * traceless_grad_v_dyadic_grad_v
                    + zeta0 * div_v * div_v
                    // term laplacian T
                        + lambda0 * (grad_ln_rho_scalar_grad_T + lap_T)
                ) * dt
                - v_scalar_grad_T * dt;
            GD_temp.set_pos(row, col, &new_T);
            
        }} // i, j loop closing parenthesis
    } // time step closing parenthesis
    } // if vdw_simu closing parenthesis
} // main definition closing parenthesis

*** TODO create a module for the simulation, outside of main
*** TODO verify derivatives direction
- j'ai mis comme c'est fait dans le code de Samy, mais ça me semblait
  bizarre la direction dans laquelle c'était fait...

  c'est dans les fcts:
- partial_deriv
  ------------------------------ !
- grad_scalar
  ------------------------------ !
- gradient
  ------------------------------ !
- gradient_vector
  ------------------------------ !
- div_vector
  ------------------------------ !
- div_tensor
  ------------------------------ !

*** TODO fix the grad_scalar test unit
*** TODO deal with negative log values (:todo:log:)
*** next
**** TODO make a function that takes in a SimConfig and runs the simulation
** implementation changes
*** functions
**** functions
***** for the gradient func, created partial derivative function
**** functions args
- removed the last argument, and returns the changed argument
***** v_nabla_v
gets grad_v as argument, maybe not necessary!
**** function names
***** tens_vec_product
****** rust
tens_product_vec
****** c
tens_vec_product
*** renaming
- traceless_grad_v_grad_v renamed traceless_grad_v_dyadic_grad_v
- grad_ln_rho_grad_T renamed grad_ln_rho_scalar_grad_T
- v_grad_T renamed v_scal_grad_T
- grad_ln_rho_grad_T renamed grad_ln_rho_scalar_grad_T
- v_grad_T renamed v_scal_grad_T
*** done
** done
*** plots
**** DONE adapt simplot to plot the results of my simulation on rust
CLOSED: [2022-12-01 Thu 19:45]
:LOGBOOK:
- State "DONE"       from              [2022-12-01 Thu 19:45]
:END:
*** physics loop construction
**** DONE compare my simulation outputs and samy's
CLOSED: [2022-12-05 lun. 11:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-12-05 lun. 11:56]
:END:
they are almost the same! but they have a little shift in the x direction
***** idea
idea:
- print the parameters just before the c simulation, to see it's
  actually all from the input file, and to check if the parameters are
  actually equal in my rust simu and the c simu
- compare results with exactly the same parameters

***** c code parameters (used)
****** constants
used:
- zeta0
- eta0
- lambda0
- lambda
- kB
- NY
- dy
- NX
- dx
- w
- dim
- aa
- b
- m

unused:
- Tc
- rhom_c
- Pc
- G
- DeBroglie0
- inv_m
- Jev
- hlv
- forcex
- flux
- j_wall_bot
- j_wall_top
- rho_wall
- Tw
- nsteps_eq_heat
- rho_min

****** input file
used:
- T0
- rho_liq
- rho_vap
- HISTO_SAVE
- FINAL_TIME
- dt

unused:
- STEP_EQ
- HISTO_FREQ
- T1

****** used in computations
- eta0
- m
- zeta0
- lambda
- dx
- dy
- inv_cv
- lambda0
- dim
- b
pressure
- aa
- w
- kB
fluid initialization
- T0
- rho_liq
- rho_vap
main loop
- FINAL_TIME
logging
- HISTO_SAVE


(cahn hilliard)
- kB
- aa
- w
- lambda0
- Tc
**** DONE understand why it is unstable
CLOSED: [2022-12-03 Sat 16:54]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-12-03 Sat 16:54]
:END:

why ? the time step was not tiny enough, and I needed to put the
derivatives like it is done in samy's code, even though it's counter
intuitive


***** DONE the grad x/y in samy is not in the same direction as mine
CLOSED: [2022-12-03 Sat 16:59]
:LOGBOOK:
- State "DONE"       from "TOCHECK"    [2022-12-03 Sat 16:59]
:END:
in his grad.x it's a gradient through the row axis (so the y axis!)
***** DONE update verification
CLOSED: [2022-12-03 Sat 13:00]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-12-03 Sat 13:00]
:END:
****** things updated
- lap rho
  ok
- lap T
  ok
- grad T
  ok
- grad rho
  ok
- ln rho
  ok
- lap v
  ok
- div v
  ok
- grad v
  ok
- grad ln rho
  ok
- grad div v
  ok
- traceless grad v
  ok
- vJ
  ok
- div vJ
  ok
- v scalar grad T
  ok
- traceless grad v dyadic grad
  ok
- v scalar grad ln rho
  ok
- pressure
  ok
- grad ln rho traceless grad v
  ok
- grad ln rho scalar grad T
  ok
- div press
  ok
***** DONE conservation eq verification
CLOSED: [2022-12-03 Sat 16:59]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-12-03 Sat 16:59]
:END:
****** DONE momentum
CLOSED: [2022-12-03 Sat 13:12]
:LOGBOOK:
- State "DONE"       from              [2022-12-03 Sat 13:12]
:END:
****** DONE mass
CLOSED: [2022-12-03 Sat 13:16]
:LOGBOOK:
- State "DONE"       from              [2022-12-03 Sat 13:16]
:END:
****** DONE thermal energy
CLOSED: [2022-12-03 Sat 16:59]
:LOGBOOK:
- State "DONE"       from              [2022-12-03 Sat 16:59]
:END:
***** DONE functions verification
CLOSED: [2022-12-03 Sat 16:59]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-12-03 Sat 16:59]
:END:
- shear_viscosity
  ok
- bulk_viscosity
  ok
- dissipative_stress
  ok
- v_nabla_v
  ok
- scal_product
  ok
- tens_product_vec
  ok
- dyadic_product
  ok
- partial_deriv
  ok
- grad_scalar
  ------------------------------ !
- gradient
  ------------------------------ !
- gradient_vector
  ------------------------------ !
- div_vector
  ------------------------------ !
- div_tensor
  ------------------------------ !
- lap_scalar
  ok
- laplacian
  ok
- laplacian_vector
  ok
- grad_div_vel
  ok
- pressure
  ok
**** DONE don't forget to update v with updated J at the end
CLOSED: [2022-12-01 Thu 19:45]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-12-01 Thu 19:45]
:END:
**** DONE check indexing
CLOSED: [2022-12-01 Thu 19:44]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-12-01 Thu 19:44]
:END:
I think I have problems with indexing:
- i, j, x_size, y_size...
- the position in [ ][ ] for my stuff...
- fix ALL THAT
**** DONE write conservation equations
CLOSED: [2022-12-01 Thu 16:21]
:LOGBOOK:
- State "DONE"       from              [2022-12-01 Thu 16:21]
:END:
**** DONE compute all the terms needed for the main loop
CLOSED: [2022-12-01 Thu 15:07]
:LOGBOOK:
- State "DONE"       from              [2022-12-01 Thu 15:07]
:END:
***** details
****** traceless_grad_v
- [ ] TensorField2D grad_v
- [ ] ScalarField2D div_v
****** momentum eq
- [ ] f32 dt (no computation needed)
- [ ] VectorField2D lap_v
- [ ] VectorField2D div_vJ = div(vJ)
- [ ] VectorField2D grad_div_v = grad_div_function on velocity
- [ ] VectorField2D grad_ln_rho_traceless_grad_v =
  tens_vec_product(traceless_grad_v, grad_ln_rho)
- [ ] VectorField2D grad_ln_rho
- [ ] VectorField2D div_press = div_tensor(press)
- [ ] ScalarField2D div_v

already done
- rho

constants
- eta0
- zeta0
****** thermal energy
- const (not defined) cv = 1.5*kB
- 1/cv
- div_v
- traceless_grad_v_grad_v
- grad_ln_rho_grad_T
- lap_T
- v_grad_T

constants
- eta0
- zeta0
- lambda0

****** mass
- ScalarField2D div_v
- f32 v_grad_ln_rho = scalar_product(v, grad_ln_rho)
- VectorField2D grad_ln_rho

functions:
- exp (check gsl lib)

***** computed
- [X] div_press
- [X] grad_ln_rho_grad_T renamed grad_ln_rho_scalar_grad_T
- [X] grad_ln_rho_traceless_grad_v
- [X] press
- [X] v_grad_ln_rho
- [X] traceless_grad_v_grad_v renamed GD_traceless_grad_v_dyadic_grad_v
- [X] v_grad_T renamed GD_v_scal_grad_T
- [X] div_vJ
- [X] vJ
- [X] grad_div_v
- [X] grad_ln_rho
- [X] grad_v
- [X] div_v
- [X] lap_v
- [X] ln_rho
- [X] grad_rho
- [X] lap_rho
- [X] lap_T
- [X] grad_T

***** dependencies list
| name                         | dependencies |
|------------------------------+--------------|
| div_press                    |            5 |
| grad_ln_rho_grad_T           |            5 |
| grad_ln_rho_traceless_grad_v |            4 |
| press                        |            4 |
| v_grad_ln_rho                |            4 |
| traceless_grad_v_grad_v      |            3 |
| v_grad_T                     |            3 |
| div_vJ                       |            2 |
| vJ                           |            2 |
| grad_div_v                   |            2 |
| grad_ln_rho                  |            2 |
| grad_v                       |            1 |
| div_v                        |            1 |
| lap_v                        |            1 |
| ln_rho                       |            1 |
| grad_rho                     |            1 |
| lap_rho                      |            1 |
| lap_T                        |            1 |
| grad_T                       |            1 |
**** DONE define all the terms needed for the main loop
CLOSED: [2022-12-01 Thu 15:02]
:LOGBOOK:
- State "DONE"       from              [2022-12-01 Thu 15:02]
:END:
***** DONE all variables checked
CLOSED: [2022-12-01 Thu 15:02]
:LOGBOOK:
- State "DONE"       from              [2022-12-01 Thu 15:02]
:END:
- [X] TensorField2D grad_v
- [X] ScalarField2D div_v
- [X] f32 dt (no computation needed)
- [X] VectorField2D lap_v
- [X] VectorField2D div_vJ = div(vJ)
- [X] VectorField2D grad_div_v = grad_div_function on velocity
- [X] VectorField2D grad_ln_rho_traceless_grad_v =
  tens_vec_product(traceless_grad_v, grad_ln rho)
- [X] VectorField2D grad_ln_rho
- [X] VectorField2D div_press = div_tensor(press)
- [X] ScalarField2D div_v
- [X] const (not defined) cv = 1.5*kB
- [X] 1/cv
- [X] div_v
- [X] traceless_grad_v_grad_v =
  dyadic_product(traceless_grad_v,grad_v)
  traceless_grad_v_grad_v renamed traceless_grad_v_dyadic_grad_v
- [X] grad_ln_rho_grad_T = scal_product(grad_ln_rho,grad_T)
  grad_ln_rho_grad_T renamed grad_ln_rho_scalar_grad_T
- [X] lap_T
- [X] v_grad_T renamed v_scal_grad_T
***** DONE traceless_grad_v
CLOSED: [2022-11-30 Wed 17:23]
:LOGBOOK:
- State "DONE"       from              [2022-11-30 Wed 17:23]
:END:
- [X] TensorField2D grad_v
- [X] ScalarField2D div_v
***** DONE momentum eq
CLOSED: [2022-11-30 Wed 20:07]
:LOGBOOK:
- State "DONE"       from              [2022-11-30 Wed 20:07]
:END:
- [X] f32 dt (no computation needed)
- [X] VectorField2D lap_v
- [X] VectorField2D div_vJ = div(vJ)
- [X] VectorField2D grad_div_v = grad_div_function on velocity
- [X] VectorField2D grad_ln_rho_traceless_grad_v =
  tens_vec_product(traceless_grad_v, grad_ln rho)
- [X] VectorField2D grad_ln_rho
- [X] VectorField2D div_press = div_tensor(press)
- [X] ScalarField2D div_v

already done
- rho

constants
- eta0
- zeta0
***** DONE thermal energy
CLOSED: [2022-12-01 Thu 15:01]
:LOGBOOK:
- State "DONE"       from              [2022-12-01 Thu 15:01]
:END:
- [X] const (not defined) cv = 1.5*kB
- [X] 1/cv
- [X] div_v
- [X] traceless_grad_v_grad_v =
  dyadic_product(traceless_grad_v,grad_v)
  traceless_grad_v_grad_v renamed traceless_grad_v_dyadic_grad_v
- [X] grad_ln_rho_grad_T = scal_product(grad_ln_rho,grad_T)
  grad_ln_rho_grad_T renamed grad_ln_rho_scalar_grad_T
- [X] lap_T
- [X] v_grad_T renamed v_scal_grad_T

constants
- eta0
- zeta0
- lambda0

***** DONE ln rho
CLOSED: [2022-12-01 Thu 15:01]
:LOGBOOK:
- State "DONE"       from              [2022-12-01 Thu 15:01]
:END:
- ScalarField2D div_v
- f32 v_grad_ln_rho = scalar_product(v, grad_ln_rho)
- VectorField2D grad_ln_rho

functions:
- exp (check gsl lib)
*** api
**** DONE function that creates a default/template SimConfig
CLOSED: [2022-11-25 ven. 15:40]
:LOGBOOK:
- State "DONE"       from              [2022-11-25 ven. 15:40]
:END:

** tohos
*** TOHO separate constants from functions
*** TOHO colorful outputs
https://docs.rs/colored/latest/colored/
*** TOHO to verify/test
**** div tensor
in fcts
**** laplacian
in fcts

seems to returns 0 a lot...
*** TOHO Cahn_Hilliard
not done because it seems it's not used in the code
*** TOHO move fn create objects in another place than main
*** TOHO remove things like "as i32" or "as usize" if possible
*** TOHO harmoniser les fonctions qui prennent VecVec et MyStructs
exemple:
- gradient/grad_scalar

mais aussi:
- laplacian
*** TOCHECK traceless_grad_v doesn't appear in dependencies py program?
*** TOHO verify if all pub is
is the good way to go in "./src/configfile/cfg_struct.rs"
*** TOHO remove all the "allow"
unused_variables
*** TOHO remove & in setter for scalar fields
